# JAVA
* [JDK](#Java-Development-Kit)
* [Java Virtual Machine(JVM)](#Java-Virtual-Machine)
  * [What is Java Virtual Machine](#What-is-Java_Virtual_Machine-?)
  * [Volatile](#Volatile)


---
## Jave Development Kit
### JDK
> JDK 是用于支持Java程序开发的最小环境   

Java 程序设计语言   
Java 虚拟机   
Java类库

### JRE (Java Runtime Environment) 
>JRE 是支持Java程序运行的标准环境   

Java 虚拟机   
Java类库中的Java API SE

---

## Java Virtual Machine
### What is Java Virtual Machine?
Java Virtual Machine (JVM) is a engine that provides runtime environment to drive the Java Code or applications. It converts Java bytecode into machines language. JVM is a part of Java Run Environment (JRE). In other programming languages, the compiler produces machine code for a particular system. However, Java compiler produces code for a Virtual Machine known as Java Virtual Machine.

- JVM is the one that actually calls the main method present in a java code. 

Java applications are called WORA (Write Once Run Anywhere). This means a programmer can develop Java code on one system and can expect it to run on any other Java enabled system without any adjustment. This is all possible because of JVM.

When we compile a .java file, .class files(contains byte-code) with the same class names present in .java file are generated by the Java compiler. This .class file goes into various steps when we run it. These steps together describe the whole JVM.

### How JVM works?
- First, Java code is complied into bytecode. This bytecode gets interpreted on different machines
- Between host system and Java source, Bytecode is an intermediary language.
- JVM is responsible for allocating memory space.

### JVM Architecture
It contains classloader, memory area, execution engine etc.

<div align="center">
<img src="https://www.guru99.com/images/1/2.png" width="500" height="300"></img>
</div>

![imgaes](JVM.png)
#### 程序计数器(Program Counter Register)   
程序计数器是一块较小的内存空间，它可以看作是当前线程所执行的字节码的信号指示器。在Java虚拟机的概念模型里，字节码解释器工作时就是通过改变这个计数器的值来选取下一条需要执行的字节码指令。   

由于Java虚拟机的多线程是通过线程轮流切换、分配处理器执行时间的方式来实现的。在任何一个确定的时刻，一个处理器（对于多核处理器来说是一个内核）都只会执行一条线程中的指令。因此，为了线程切换后能恢复到正确的执行位置，**每条线程都需要一个独立的程序计数器，各线程之间计数器互不影响，独立存储，我们称这类内存区域为“线程私有”内存**。   

如果线程正在执行的是一个Java方法，这个计数器记录的是正在执行的虚拟机字节码指令的地址.   
如果线程正在执行的是一个本地（Native）方法，这个计数器的值则为Undefined。   
(此内存区域是唯一一个在《Java虚拟机规范》中没有规定任何OutOfMemoryError情况的区域)   

#### Java虚拟机栈(Java Virtual Machine Stack)
Java Virtual Machine Stack也是线程私有的，他的生命周期与线程相同。虚拟机栈描述的是Java方法执行的线程内存模型；每个方法被执行的时候，Java虚拟机都会同步创建一个Stack Frame 用于存储**局部变量表**，操作数栈，动态连接，方法出口等信息。每一个方法被调用直至执行完毕的过程，就是对应着一个这Stack Frame在虚拟机栈中从入栈到出栈的过程。
- 局部变量表存放了编译期可知的各种Java虚拟机基本数据类型（boolean, byte, char, short, int, float, long, double)、对象饮用(reference 类型，它并不等同于对象本身，可能是一个指向对象起始地址的引用指针，也可能是指向一个代表对象的句柄或者其他与对象相关的位置)和returenAddress类型（指向了一条字节码指令的地址）。  
- 这些数据类型在局部变量表中的以Slot来表示，其中64位长度的long和double类型的数据会占用两个slot，其余的数据类型只占用一个。**局部变量表所需的内存空间在编译期间完成分配，当进入一个方法时，一个方法需要在stack frame里分配多大的局部变量空间是完全确定的，在方法运行期间不会改变局部变量表的大小**。（“大小”指slot的数量，虚拟机真正使用多大的内存空间来实现一个slot完全是虚拟机实现自行决定的）   

在《Java虚拟机规范》中，对这个内存区域规定了两类异常状况：
- 如果线程请求的深度大于虚拟机所允许的深度，将抛出StackOverFlowError异常
- 如果Java虚拟机栈（stack）容量可以动态扩展，当栈扩展时无法申请到足够的内存会抛出OutOfMemoryError异常   

#### 本地方法栈(Native Method Stacks)










---

## Volatile
### Why use volatile?
Using volatile is yet another way (like synchronized, atomic wrapper) of making class thread safe. Thread safe means that a method or class instance can be used by multiple threads at the same time without any problem.

### 特性
- 1.可见性/visible。对一个volatile变量的读，总是能看到（任意线程）对这个volatile变量最后的写入。
- 2.原子性/atomic。对任意单个volatile变量的读/写具有原子性，但类似于volatile++这种复合操作不具有原子性。

<img src="https://github.com/ZikunLyu/MambaForever/blob/master/images/volatile.png" height="500"></img>

### volatile vs static
Note that volatile should not be confused with static modifier.   
static variables are class members that are shared among all objects. There is only one copy of them in main memory.

### volatile vs synchronized
Before we move on let’s take a look at two important features of locks and synchronization.   
- 1.Mutual Exclusion: It means that only one thread or process can execute a block of code (critical section) at a time.
- 2.Visibility: It means that changes made by one thread to shared data are visible to other threads.

Java’s synchronized keyword guarantees both mutual exclusion and visibility.   
- If we make the blocks of threads that modifies the value of shared variable synchronized only one thread can enter the block and changes made by it will be reflected in the main memory.   
All other thread trying to enter the block at the same time will be blocked and put to sleep.

In some cases we may only desire the visibility and not atomicity. Use of synchronized in such situation is an overkill and may cause scalability problems. Here volatile comes to the rescue.   
- Volatile variables have the visibility features of synchronized but not the atomicity features.   
The values of volatile variable will never be cached and all writes and reads will be done to and from the main memory.    

However, use of volatile is limited to very restricted set of cases as most of the times atomicity is desired.   
- For example a simple increment statement such as x = x + 1; or x++ seems to be a single operation but is s really a compound read-modify-write sequence of operations that must execute atomically.

### volatile write
当写一个volatile变量时，JMM会把该线程对应的本地中的共享变量值刷新到主内存。




