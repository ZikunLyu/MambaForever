# JAVA
* [Java Virtual Machine(JVM)](#Java-Virtual-Machine)
  * [What is Java Virtual Machine](#What-is-Java_Virtual_Machine-?)
  * [Volatile](#Volatile)
  



### Java Virtual Machine
#### What is Java Virtual Machine?
Java Virtual Machine (JVM) is a engine that provides runtime environment to drive the Java Code or applications. It converts Java bytecode into machines language. JVM is a part of Java Run Environment (JRE). In other programming languages, the compiler produces machine code for a particular system. However, Java compiler produces code for a Virtual Machine known as Java Virtual Machine.

- JVM is the one that actually calls the main method present in a java code. 

Java applications are called WORA (Write Once Run Anywhere). This means a programmer can develop Java code on one system and can expect it to run on any other Java enabled system without any adjustment. This is all possible because of JVM.

When we compile a .java file, .class files(contains byte-code) with the same class names present in .java file are generated by the Java compiler. This .class file goes into various steps when we run it. These steps together describe the whole JVM.

#### How JVM works?
- First, Java code is complied into bytecode. This bytecode gets interpreted on different machines
- Between host system and Java source, Bytecode is an intermediary language.
- JVM is responsible for allocating memory space.

#### JVM Architecture
It contains classloader, memory area, execution engine etc.

<div align="center">
<img src="https://www.guru99.com/images/1/2.png" width="500" height="300"></img>
</div>

### Volatile
#### Why use volatile?
Using volatile is yet another way (like synchronized, atomic wrapper) of making class thread safe. Thread safe means that a method or class instance can be used by multiple threads at the same time without any problem.

#### 特性
- 1.可见性/visible。对一个volatile变量的读，总是能看到（任意线程）对这个volatile变量最后的写入。
- 2.原子性/atomic。对任意单个volatile变量的读/写具有原子性，但类似于volatile++这种复合操作不具有原子性。

<img src="https://github.com/ZikunLyu/MambaForever/blob/master/images/volatile.png" height="500"></img>

#### volatile vs static
Note that volatile should not be confused with static modifier.   
static variables are class members that are shared among all objects. There is only one copy of them in main memory.

#### volatile vs synchronized
Before we move on let’s take a look at two important features of locks and synchronization.   
- 1.Mutual Exclusion: It means that only one thread or process can execute a block of code (critical section) at a time.
- 2.Visibility: It means that changes made by one thread to shared data are visible to other threads.

Java’s synchronized keyword guarantees both mutual exclusion and visibility.   
- If we make the blocks of threads that modifies the value of shared variable synchronized only one thread can enter the block and changes made by it will be reflected in the main memory.   
All other thread trying to enter the block at the same time will be blocked and put to sleep.

In some cases we may only desire the visibility and not atomicity. Use of synchronized in such situation is an overkill and may cause scalability problems. Here volatile comes to the rescue.   
- Volatile variables have the visibility features of synchronized but not the atomicity features.   
The values of volatile variable will never be cached and all writes and reads will be done to and from the main memory.    

However, use of volatile is limited to very restricted set of cases as most of the times atomicity is desired.   
- For example a simple increment statement such as x = x + 1; or x++ seems to be a single operation but is s really a compound read-modify-write sequence of operations that must execute atomically.

#### volatile write
当写一个volatile变量时，JMM会把该线程对应的本地中的共享变量值刷新到主内存。




